# #  CD PIPELINE

# trigger: none  

# resources:
#   pipelines:
#   - pipeline: CI       
#     source: ToDo-CI 
#     trigger:
#       branches:
#         - main          

# pool:
#   vmImage: ubuntu-latest

# variables:
#   PROJECT_ID: 'fluted-factor-438905-d2'
#   REGION: 'asia-south1'
#   REPO_NAME: 'todo-repo'
#   CLUSTER_NAME: 'todo-cluster'
#   CLUSTER_ZONE: 'asia-south1-a'
#   SERVICE_ACCOUNT: 'todo-deployer@fluted-factor-438905-d2.iam.gserviceaccount.com'

# stages:
# - stage: Deploy
#   displayName: Deploy to GKE
#   jobs:
#   - deployment: DeployToGKE
#     environment: 'production'
#     strategy:
#       runOnce:
#         deploy:
#           steps:
#           - checkout: self

#           # Download Secure File (GCP Service Account JSON)
#           - task: DownloadSecureFile@1
#             name: GCloudKey
#             inputs:
#               secureFile: 'key.json'   # must match the name in Secure Files

#           # Authenticate with Google Cloud using secure key
#           - task: Bash@3
#             displayName: 'Authenticate with Google Cloud'
#             inputs:
#               targetType: 'inline'
#               script: |
#                 echo "Authenticating to GCP and configuring kubectl..."

#                 # Activate service account
#                 gcloud auth activate-service-account $SERVICE_ACCOUNT --key-file "$(GCloudKey.secureFilePath)"
#                 gcloud config set project $PROJECT_ID

#                 #  Properly install GKE gcloud auth plugin (with repo setup)
#                 echo "Installing GKE gcloud auth plugin..."
#                 sudo apt-get update -y
#                 sudo apt-get install -y apt-transport-https ca-certificates gnupg curl

#                 echo "Adding Google Cloud SDK repository..."
#                 echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee -a /etc/apt/sources.list.d/google-cloud-sdk.list
#                 curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key --keyring /usr/share/keyrings/cloud.google.gpg add -
#                 sudo apt-get update -y
#                 sudo apt-get install -y google-cloud-sdk-gke-gcloud-auth-plugin

#                 # Add plugin to PATH so kubectl can find it
#                 export PATH=$PATH:/usr/lib/google-cloud-sdk/bin

#                 #  Set environment variable for kubectl authentication
#                 export USE_GKE_GCLOUD_AUTH_PLUGIN=True

#                 #  Fetch cluster credentials
#                 gcloud container clusters get-credentials $CLUSTER_NAME --zone $CLUSTER_ZONE --project $PROJECT_ID

#                 #  Verify plugin works
#                 gke-gcloud-auth-plugin --version || echo "Plugin installed successfully!"
#             env:
#               PROJECT_ID: $(PROJECT_ID)
#               CLUSTER_NAME: $(CLUSTER_NAME)
#               CLUSTER_ZONE: $(CLUSTER_ZONE)
#               SERVICE_ACCOUNT: $(SERVICE_ACCOUNT)

#           - task: Bash@3
#             displayName: 'Create or Update Secrets and ConfigMaps'
#             inputs:
#               targetType: 'inline'
#               script: |
#                 echo "Ensuring Secrets and ConfigMaps exist..."
#                 kubectl create configmap backend-config \
#                   --from-literal=DB_HOST=mysql-service \
#                   --from-literal=DB_USER=root \
#                   --from-literal=DB_NAME=todo \
#                   --from-literal=DB_PORT=3306 \
#                   --from-literal=PORT=3000 \
#                   --from-literal=ALLOWED_ORIGIN=* \
#                   --dry-run=client -o yaml | kubectl apply -f -
                
#                 kubectl create secret generic mysql-secret \
#                   --from-literal=mysql-root-password=root \
#                   --dry-run=client -o yaml | kubectl apply -f -

#                 echo " Secrets and ConfigMaps ensured successfully."
#           # Step: Wait for MySQL Pod to be Ready
#           - task: Bash@3
#             displayName: 'Wait for MySQL Pod to be Ready'
#             inputs:
#               targetType: 'inline'
#               script: |
#                 echo "Waiting for MySQL pod to become ready..."
#                 kubectl wait --for=condition=ready pod -l app=mysql --timeout=300s
#                 echo " MySQL pod is ready."

#           # Step: Auto-create Database and Table
#           - task: Bash@3
#             displayName: 'Wait until MySQL is accepting connections'
#             inputs:
#               targetType: 'inline'
#               script: |
#                 MYSQL_POD=$(kubectl get pod -l app=mysql -o jsonpath="{.items[0].metadata.name}")
#                 echo "Checking MySQL readiness inside pod: $MYSQL_POD"
                
#                 # Loop until MySQL responds
#                 for i in {1..30}; do
#                   kubectl exec $MYSQL_POD -- mysqladmin ping -u root -proot --silent && break
#                   echo " Waiting for MySQL to be ready... ($i/30)"
#                   sleep 5
#                 done

#                 echo " MySQL is accepting connections now."

#           # Create database and table
#           - task: Bash@3
#             displayName: 'Initialize Database and Table'
#             inputs:
#               targetType: 'inline'
#               script: |
#                 set -e
#                 MYSQL_POD=mysql-0
                
#                 echo "Using MySQL pod: $MYSQL_POD"
#                 MYSQL_ROOT_PASSWORD=myStrongPassword123
#                 for i in {1..30}; do
#                    kubectl exec $MYSQL_POD -- mysqladmin ping -u root -p$MYSQL_ROOT_PASSWORD --silent && break
#                   echo " Waiting for MySQL to be ready... ($i/30)"
#                   sleep 5
#                 done

#                 echo " MySQL accepting connections, creating database..."
#                 kubectl exec -i $MYSQL_POD -- mysql -h 127.0.0.1 -u root -p$MYSQL_ROOT_PASSWORD <<EOF
#                 CREATE DATABASE IF NOT EXISTS todo;
#                 USE todo;
#                 CREATE TABLE IF NOT EXISTS tasks (
#                     id INT AUTO_INCREMENT PRIMARY KEY,
#                     title VARCHAR(255) NOT NULL
#                 );
#                 EOF
#                 echo " Database and table initialization completed successfully."

#           # Deploy images to GKE
#           - task: Bash@3
#             displayName: 'Deploy to GKE'
#             inputs:
#               targetType: 'inline'
#               script: |
#                 export USE_GKE_GCLOUD_AUTH_PLUGIN=True
#                 BUILD_ID=$(resources.pipeline.CI.runID)
#                 echo "Deploying images tagged with Build ID: $BUILD_ID"
#                 sed -i "s|IMAGE_FRONTEND|$REGION-docker.pkg.dev/$PROJECT_ID/$REPO_NAME/frontend:$BUILD_ID|g" k8s/frontend-deployment.yaml
#                 sed -i "s|IMAGE_BACKEND|$REGION-docker.pkg.dev/$PROJECT_ID/$REPO_NAME/backend:$BUILD_ID|g" k8s/backend-deployment.yaml

#                 kubectl apply -f k8s/ --validate=false
#             env:
#               REGION: $(REGION)
#               PROJECT_ID: $(PROJECT_ID)
#               REPO_NAME: $(REPO_NAME)

# ============================================
# üöÄ  CD Pipeline ‚Äì Terraform + Helm Deployment
# ============================================

# trigger: none

# resources:
#   pipelines:
#   - pipeline: CI
#     source: ToDo-CI
#     trigger:
#       branches:
#         - main

# pool:
#   vmImage: ubuntu-latest

# variables:
#   PROJECT_ID: 'fluted-factor-438905-d2'
#   REGION: 'asia-south1'
#   REPO_NAME: 'todo-repo'
#   CLUSTER_NAME: 'todo-cluster'
#   CLUSTER_ZONE: 'asia-south1-a'
#   SERVICE_ACCOUNT: 'todo-deployer@fluted-factor-438905-d2.iam.gserviceaccount.com'

# stages:
# - stage: Deploy
#   displayName: Deploy with Terraform & Helm
#   jobs:
#   - job: DeployToGKE
#     displayName: "Terraform Apply & Helm Deploy"
#     steps:
#     - checkout: self

#     # Download GCP Service Account Key
#     - task: DownloadSecureFile@1
#       name: GCloudKey
#       inputs:
#         secureFile: 'key.json'

#     # Authenticate to Google Cloud & Get Cluster Credentials
#     - task: Bash@3
#       displayName: 'Authenticate to GCP'
#       inputs:
#         targetType: 'inline'
#         script: |
#           echo "Authenticating to GCP..."
#           gcloud auth activate-service-account $SERVICE_ACCOUNT --key-file "$(GCloudKey.secureFilePath)"
#           gcloud config set project $PROJECT_ID
#           gcloud components install gke-gcloud-auth-plugin
#           export USE_GKE_GCLOUD_AUTH_PLUGIN=True
#           gcloud container clusters get-credentials $CLUSTER_NAME --zone $CLUSTER_ZONE --project $PROJECT_ID
#       env:
#         PROJECT_ID: $(PROJECT_ID)
#         CLUSTER_NAME: $(CLUSTER_NAME)
#         CLUSTER_ZONE: $(CLUSTER_ZONE)
#         SERVICE_ACCOUNT: $(SERVICE_ACCOUNT)

#     # Terraform Apply (Infra)
#     - task: Bash@3
#       displayName: 'Terraform Apply (GKE + IP + GAR)'
#       inputs:
#         targetType: 'inline'
#         script: |
#           cd terraform
#           terraform init
#           terraform apply -auto-approve
#           cd ..

#     # Install Helm
#     - task: HelmInstaller@1
#       inputs:
#         helmVersionToInstall: '3.14.0'

#     # Helm Deploy Application
#     - task: Bash@3
#       displayName: 'Deploy Helm Chart to GKE'
#       inputs:
#         targetType: 'inline'
#         script: |
#           set -e
#           BUILD_ID=$(resources.pipeline.CI.runID)
#           echo "Deploying images tagged with Build ID: $BUILD_ID"

#           helm upgrade --install todo-app ./helm \
#             --set backend.image=$REGION-docker.pkg.dev/$PROJECT_ID/$REPO_NAME/backend:$BUILD_ID \
#             --set frontend.image=$REGION-docker.pkg.dev/$PROJECT_ID/$REPO_NAME/frontend:$BUILD_ID \
#             --set mysql.rootPassword=myStrongPassword123

#           echo " Helm deployment completed successfully!"

#     #  (Optional) Verify Deployment
#     - task: Bash@3
#       displayName: "Verify Deployed Pods & Services"
#       inputs:
#         targetType: 'inline'
#         script: |
#           echo "Current pods:"
#           kubectl get pods -o wide
#           echo "Current services:"
#           kubectl get svc -o wide

trigger: none

resources:
  pipelines:
  - pipeline: CI
    source: ToDo-CI
    trigger:
      branches:
        - main

pool:
  vmImage: ubuntu-latest

variables:
  PROJECT_ID: 'fluted-factor-438905-d2'
  REGION: 'asia-south1'
  REPO_NAME: 'todo-repo'
  CLUSTER_NAME: 'todo-cluster'
  CLUSTER_ZONE: 'asia-south1-a'
  SERVICE_ACCOUNT: 'todo-deployer@fluted-factor-438905-d2.iam.gserviceaccount.com'

stages:
- stage: Deploy
  displayName: Deploy using Terraform & Helm
  jobs:
  - job: DeployToGKE
    displayName: Apply Infra + Deploy App
    steps:
    - checkout: self

    # 1Ô∏è‚É£ DOWNLOAD ARTIFACTS
    - download: CI
      artifact: deploy_artifacts
      displayName: "Download deploy artifacts"

    - task: Bash@3
      displayName: "List downloaded artifacts"
      inputs:
        targetType: inline
        script: |
          echo "Downloaded files:"
          ls -R $(Pipeline.Workspace)/CI/deploy_artifacts

    # 2Ô∏è‚É£ PARSE deploy_info.txt
    - task: Bash@3
      displayName: "Extract deploy metadata"
      inputs:
        targetType: inline
        script: |
          FILE=$(Pipeline.Workspace)/CI/deploy_artifacts/deploy_info.txt

          export STATIC_IP=$(grep STATIC_IP $FILE | cut -d'=' -f2)
          export FRONTEND_TAG=$(grep FRONTEND_TAG $FILE | cut -d'=' -f2)
          export BACKEND_TAG=$(grep BACKEND_TAG $FILE | cut -d'=' -f2)

          echo "STATIC_IP=$STATIC_IP"
          echo "FRONTEND_TAG=$FRONTEND_TAG"
          echo "BACKEND_TAG=$BACKEND_TAG"

          echo "##vso[task.setvariable variable=STATIC_IP]$STATIC_IP"
          echo "##vso[task.setvariable variable=FRONTEND_TAG]$FRONTEND_TAG"
          echo "##vso[task.setvariable variable=BACKEND_TAG]$BACKEND_TAG"

    # 3Ô∏è‚É£ AUTHENTICATE GCP
    - task: DownloadSecureFile@1
      name: GCloudKey
      inputs:
        secureFile: 'key.json'

    - task: Bash@3
      displayName: "Authenticate to GCP"
      inputs:
        targetType: inline
        script: |
          echo "Authenticating..."
          gcloud auth activate-service-account $SERVICE_ACCOUNT --key-file "$(GCloudKey.secureFilePath)"
          gcloud config set project $PROJECT_ID
          export USE_GKE_GCLOUD_AUTH_PLUGIN=True
          gcloud container clusters get-credentials $CLUSTER_NAME --zone $CLUSTER_ZONE

    # 4Ô∏è‚É£ INSTALL TERRAFORM
    - task: TerraformInstaller@1
      displayName: "Install Terraform"
      inputs:
        terraformVersion: '1.6.0'


    # 5Ô∏è‚É£ TERRAFORM APPLY
    - task: Bash@3
      displayName: "Terraform Apply"
      inputs:
        targetType: inline
        script: |
          cd $(Pipeline.Workspace)/CI/deploy_artifacts/terraform
          
          terraform init

          BASE64_KEY=$(cat "$(GCloudKey.secureFilePath)" | base64 | tr -d '\n')

          cat <<EOF > terraform.auto.tfvars
          project_id      = "${PROJECT_ID}"
          region          = "${REGION}"
          zone            = "${CLUSTER_ZONE}"
          gcp_credentials = "${BASE64_KEY}"
          EOF

          echo "Generated terraform.auto.tfvars:"
          cat terraform.auto.tfvars

          terraform apply -auto-approve


    # 6Ô∏è‚É£ INSTALL HELM
    - task: HelmInstaller@1
      inputs:
        helmVersionToInstall: '3.14.0'

    # 7Ô∏è‚É£ HELM DEPLOY
    - task: Bash@3
      displayName: "Deploy Helm Chart"
      inputs:
        targetType: inline
        script: |
          CHART=$(Pipeline.Workspace)/CI/deploy_artifacts/*.tgz

          helm upgrade --install todo-app $CHART \
            --set backend.image=$REGION-docker.pkg.dev/$PROJECT_ID/$REPO_NAME/backend:$(BACKEND_TAG) \
            --set frontend.image=$REGION-docker.pkg.dev/$PROJECT_ID/$REPO_NAME/frontend:$(FRONTEND_TAG) \
            --set backend.staticIP=$(STATIC_IP)

          echo "Deployment completed!"

    # 8Ô∏è‚É£ VERIFY
    - task: Bash@3
      displayName: "Verify Deployment"
      inputs:
        targetType: inline
        script: |
          kubectl get pods -o wide
          kubectl get svc -o wide
